"""sudoku_helper.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Pk3rKeTsgY1yhibGvcyE5YtRlXuUV2Nz
"""
"""
#all the required packages are imported here
from tensorflow.keras import Sequential
from tensorflow.keras.layers import Conv2D
from tensorflow.keras.layers import MaxPooling2D
from tensorflow.keras.layers import Activation
from tensorflow.keras.layers import Flatten
from tensorflow.keras.layers import Dense
from tensorflow.keras.layers import Dropout,BatchNormalization
from imutils.perspective import four_point_transform
from skimage.segmentation import clear_border
import tensorflow.keras
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import cv2
import imutils

#train paramenters
my_learaning_rate=0.3
iters=30
train_val_split=0.8
batch_size=100

#prepping data::)
def train_val(ratio,data):
  x=int(ratio*data.shape[0])
  df1=data[0:x]
  df2=data[x:data.shape[0]]
  return (df1,df2)
def convert(arr,rows,column):
  col=arr.columns
  t=arr[col[0]].size
  df=arr.to_numpy()
  df=np.reshape(df,(t,rows,column,1))
  return df

raw_train=pd.read_csv('train.csv')
raw_test=pd.read_csv('test.csv')
raw_train_y=raw_train['label']
print(raw_train.shape)
raw_train=pd.DataFrame(raw_train.values[:, 1:])
raw_train=raw_train.astype('float32')/255
raw_test=raw_test.astype('float32')/255
data_x=convert(raw_train,28,28)
data_test=convert(raw_test,28,28)
data_train,data_val=train_val(0.8,data_x)
data_train_y,data_val_y=train_val(0.8,raw_train_y)

#training our digit recongniser again::
model=Sequential()
model.add(Conv2D(32,(3,3),activation='relu',kernel_initializer="he_uniform",input_shape=(28,28,1)))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2),padding="valid"))
model.add(Dropout(0.25))
model.add(Conv2D(64,(3,3),activation="relu",kernel_initializer="he_uniform"))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2),padding="valid"))
model.add(Dropout(0.25))
model.add(Conv2D(64,(3,3),activation="relu",kernel_initializer="he_uniform"))
model.add(BatchNormalization())
model.add(MaxPooling2D(pool_size=(2,2),padding="valid"))
model.add(Flatten())
model.add(Dense(64,activation="relu",kernel_initializer="he_uniform"))
model.add(Dropout(0.25))
model.add(Dense(32,activation="relu",kernel_initializer="he_uniform"))
model.add(Dropout(0.25))
model.add(Dense(10,activation="softmax"))
opt=tensorflow.keras.optimizers.Adam(learning_rate=my_learning_rate)
model.compile(optimizer=opt,loss='sparse_categorical_crossentropy',metrics='accuracy')
print(model.summary())

history=model.fit(data_train,data_train_y,epochs=iters,batch_size=batch_size,verbose=0)
loss,acc=model.evaluate(x_val,y_val,verbose=0)
print('loss_val ,acc_val :',"(",loss," ",acc*100,"%)")
"""
#load heroku image in order to use it with out models
from tensorflow.keras.models import load_model
from imutils.perspective import four_point_transform
from skimage.segmentation import clear_border
import numpy as np
import pandas as pd
import cv2
import imutils
def load_img(img,num=0):
   img=cv2.resize(img,(28,28))
   n_img=np.asarray(img)
   n_img=np.reshape(n_img,(28,28,1))
   if num==0:
     return n_img
   if num==1:
     return n_img.astype("float32")/255
   if num==2:
     return n_img.astype("float32")*255

#finding puzzle and reducig point view
def find_sudoku_puzzle(img):
  gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
  blurred=cv2.GuassianBlur(gray,(7,7),3)
  thresh=cv2.adaptiveThreshold(blurred,255,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,11,2)
  thresh=cv2.bitwise_not(thresh)
  cnts=cv2.findContours(thresh.copy(),cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
  cnts=imutils.grab_contours(cnts)
  cnts=sorted(cnts,key=cv2.contourArea,reverse=True)
  puzzledim=None
  for c in cnts:
    peri=cv2.arcLength(c,True)
    approx=cv2.approxPolyDP(c,0.02*peri,True)
    if len(approx)==4:
      puzzledim=approx
      break
  if puzzledim is None:
    return Exception(("cannot detect a puzzle"))
  puzzle=four_point_transform(img,puzzledim.reshape(4,2))
  warped=four_point_transform(gray,puzzledim.reshape(4,2))
  return (puzzle,warped)

#loading the puzle into an array
def digit(cel):
  cell=cv2.cvtColor(cel,cv2.COLOR_BGR2GRAY)
  thresh = cv2.threshold(cell, 0, 255,cv2.THRESH_BINARY_INV | cv2.THRESH_OTSU)[1]
  thresh = clear_border(thresh)
  cnts=cv2.findContours(thresh.copy(),cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE)
  cnts=imutils.grab_contours(cnts)
  if len(cnts)==0:
     return None
  c=max(cnts,key=cv2.contourArea)
  mask=np.zeros(thresh.shape,dtype="uint8")
  cv2.drawContours(mask,[c],-1,255,-1)
  (h,w)=thresh.shape
  percentFilled=cv2.countNonZero(mask)/float(w*h)
  if percentFilled<0.03:
    return None
  digi_img=cv2.bitwise_and(thresh,thresh,mask=mask)
  digi_img=load_img(digi_img,1)
  model=load_model('num.h5')
  ans_arr=model.predict(np.asarray([digi_img]))
  ans=np.argmax(np.asarray(ans_arr),axis=1)#to be checked again
  return ans+1
def load_puzzle(img):
   sudoku_c,sudoku_b=find_sudoku_puzzle(img)
   h,w=sudoku_b.shape
   x=h//9
   y=w//9
   arr=np.zeros((9,9))
   for i in range(9):
     for j in range(9):
       cell=img[i*x:(i+1)*x,i*y:(i+1)*y]
       x=digit(cell)
       if x is not None:
          arr[i,j]=x
   solved=solve_puzzle(arr)
   return solved

#solving sudoku puzzle using DLX and knuths:)
#!pip install exact_cover_np
import exact_cover as ec
def solve_puzzle(arr):
  g_mat=np.zeros((729,324),dtype='int32')
  sol=np.zeros((9,9))
  for i in range(9):
    for j in range(9):
      if (arr[i,j]==0):
        for k in range(9):
           g_mat[81*i+9*j+k,9*i+j]=1
           g_mat[81*i+9*j+k,81+9*i+k]=1
           g_mat[81*i+9*j+k,162+9*j+k]=1
           g_mat[81*i+9*j+k,243+9*(i//3+3*(j//3))+k]=1
      else:
        g_mat[81*i+9*j+arr[i,j]-1,9*i+j]=1
        g_mat[81*i+9*j+arr[i,j]-1,81+9*i+arr[i,j]-1]=1
        g_mat[81*i+9*j+arr[i,j]-1,162+9*j+arr[i,j]-1]=1
        g_mat[81*i+9*j+arr[i,j]-1,243+9*(i//3+3*(j//3))+arr[i,j]-1]=1
  sol_n=ec.get_exact_cover(g_mat)
  if sol_n.size==81:
      for k in sol_n:
        num=k%9+1
        k=k//9
        j=k%9
        k=k//9
        i=k%9
        sol[i,j]=num
      return sol
  else:
      return None

